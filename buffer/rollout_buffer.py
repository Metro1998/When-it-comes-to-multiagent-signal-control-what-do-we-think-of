"""
reference:
https://github.com/openai/spinningup/blob/master/spinup/algos/pytorch/ppo/ppo.py

Author:Metro
date:2023.1.10
"""

import numpy as np

class PPOBuffer:
    """
    A buffer for storing trajectories generated by (H)PPO agents interacting with
    parallel sub-environments, and using Generalized Advantage Estimation (GAE-Lambda)
    for calculating the advantages of obs-action pairs.
    """

    def __init__(self, num_steps, num_envs, num_agents, obs_dim, act_dim, device, action_type):

        self.obs_buf = np.zeros((num_steps, num_envs, num_agents, obs_dim), dtype=np.float32)

        self.action_type = action_type
        if action_type == 'Continuous':
            self.act_con_buf = np.zeros((num_steps, num_envs, num_agents, act_dim), dtype=np.float32)
            self.logp_con_buf = np.zeros((num_steps, num_envs, num_agents, act_dim), dtype=np.float32)
        elif action_type == 'Discrete':
            self.act_dis_buf = np.zeros((num_steps, num_envs, num_agents), dtype=np.int64)
            self.logp_dis_buf = np.zeros((num_steps, num_envs, num_agents), dtype=np.float32)
        else:
            self.act_con_buf = np.zeros((num_steps, num_envs, num_agents, act_dim), dtype=np.float32)
            self.logp_con_buf = np.zeros((num_steps, num_envs, num_agents, act_dim), dtype=np.float32)
            self.act_dis_buf = np.zeros((num_steps, num_envs, num_agents), dtype=np.int64)
            self.logp_dis_buf = np.zeros((num_steps, num_envs, num_agents), dtype=np.float32)

        self.rew_buf = np.zeros((num_steps, num_envs, num_agents), dtype=np.float32)
        # self.val_buf = np.zeros((num_steps, num_envs), dtype=np.float32)

        self.device = device
        self.num_steps, self.num_envs, self.num_agents = num_steps, num_envs, num_agents
        self.obs_dim, self.act_dim = obs_dim, act_dim
        self.ptr, self.path_start_dix, self.max_size = 0, 0, num_steps

    def store_trajectories(self, obs, act_dis, act_con, logp_dis, logp_con, rew, val):
        """
`       Append one timestep of agent-environment interaction to the buffer.
        ### Inputs are batch of num_envs * num_agents ###
        """
        assert self.ptr < self.max_size
        self.obs_buf[self.ptr] = obs

        if self.action_type == 'Continuous':
            self.act_con_buf[self.ptr] = act_con
            self.logp_con_buf[self.ptr] = logp_con
        elif self.action_type == 'Discrete':
            self.act_dis_buf[self.ptr] = act_dis
            self.logp_dis_buf[self.ptr] = logp_dis
        else:
            self.act_con_buf[self.ptr] = act_con
            self.act_dis_buf[self.ptr] = act_dis
            self.logp_con_buf[self.ptr] = logp_con
            self.logp_dis_buf[self.ptr] = logp_dis

        self.rew_buf[self.ptr] = rew
        # self.val_buf[self.ptr] = val
        self.ptr += 1

    def get(self):
        """
        Call this at the end of a rollout round to retrieve the full information.
        :return:
        """
        assert self.ptr == self.max_size

        # Critic will get the centralized observation, and signal sequence observation is not considered here.
        # (num_steps, num_envs, num_agents, obs_dim) --> (num_envs, num_steps, num_agents, obs_dim)
        obs_batch = self.obs_buf[:self.ptr].transpose(1, 0)
        # (num_steps, num_envs, num_agents) --> (num_envs, num_steps, num_agents)
        rew_batch = self.rew_buf[:self.ptr].transpose(1, 0)

        if self.action_type == 'Continuous':
            act_con_batch = self.act_con_buf[:self.ptr].transpose(1, 0)
            logp_con_batch = self.logp_con_buf[:self.ptr].transpose(1, 0)
            return obs_batch, rew_batch, act_con_batch, logp_con_batch

        elif self.action_type == 'Discrete':
            act_dis_batch = self.act_dis_buf[:self.ptr].transpose(1, 0)
            logp_dis_batch = self.logp_dis_buf[:self.ptr].transpose(1, 0)
            return obs_batch, rew_batch, act_dis_batch, logp_dis_batch

        else:
            act_con_batch = self.act_con_buf[:self.ptr].transpose(1, 0)
            act_dis_batch = self.act_dis_buf[:self.ptr].transpose(1, 0)
            logp_con_batch = self.logp_con_buf[:self.ptr].transpose(1, 0)
            logp_dis_batch = self.logp_dis_buf[:self.ptr].transpose(1, 0)
            return obs_batch, rew_batch, act_con_batch, act_dis_batch, logp_con_batch, logp_dis_batch

    def clear(self):
        self.ptr, self.path_start_dix = 0, 0

